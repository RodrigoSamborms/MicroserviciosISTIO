#!/usr/bin/env bash
set -euo pipefail

# Configuración
REPO_ROOT="/mnt/c/Users/sambo/Documents/Programacion/GitHub/MicroserviciosISTIO"
ISTIO_DIR="$REPO_ROOT/istio-1.28.0"
MINIKUBE_PROFILE="minikube"
MEMORY="2048"
CPUS="2"

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Funciones auxiliares
print_info() { echo -e "${BLUE}ℹ${NC} $1"; }
print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
print_error() { echo -e "${RED}✗${NC} $1"; }

# Espera a que un pod esté en estado Running
wait_for_pod_running() {
    local POD_LABEL=$1
    local NAMESPACE=${2:-istio-system}
    local TIMEOUT=${3:-120}
    
    kubectl wait --for=condition=ready pod -l "$POD_LABEL" -n "$NAMESPACE" --timeout="${TIMEOUT}s" >/dev/null 2>&1 || true
}

# Espera a que un deployment esté disponible (no falla si expira)
wait_for_deploy_available() {
    local DEPLOY=$1
    kubectl wait --for=condition=available --timeout=120s "deployment/${DEPLOY}" -n istio-system >/dev/null 2>&1 || true
}

# Inicia un dashboard en segundo plano con logs y espera
start_dashboard_pf() {
    local NAME=$1
    local PORT=$2
    local URL=$3
    local LOGFILE="/tmp/microservicios_${NAME}.log"
    local PID=""

    # Evita procesos huérfanos en el mismo puerto
    pkill -f "istioctl dashboard --port ${PORT}" 2>/dev/null || true
    sleep 1

    # Inicia port-forward en background
    nohup ./bin/istioctl dashboard --port "$PORT" --address 0.0.0.0 --browser=false "$NAME" > "$LOGFILE" 2>&1 &
    PID=$!
    
    # Espera a que el proceso se estabilice (8 segundos)
    sleep 8

    echo "$PID"
    return 0
}

# Verificar si minikube está corriendo
is_minikube_running() {
    minikube status -p "$MINIKUBE_PROFILE" 2>/dev/null | grep -q "host: Running" && return 0 || return 1
}

# Verificar si hay dashboards corriendo
get_dashboard_pids() {
    pgrep -f "istioctl dashboard" 2>/dev/null || true
}

count_dashboards() {
    get_dashboard_pids | wc -l
}

# START: Iniciar sesión
cmd_start() {
    print_info "Iniciando sesión de microservicios..."
    
    # Verificar si ya está corriendo
    if is_minikube_running; then
        print_warning "Minikube ya está en ejecución"
        print_info "Usa 'status' para ver detalles o 'stop' para detener"
        return 0
    fi
    
    # Iniciar minikube
    print_info "Iniciando minikube (memoria=${MEMORY}MB, cpus=${CPUS})..."
    minikube start --driver=docker --memory="$MEMORY" --cpus="$CPUS" -p "$MINIKUBE_PROFILE"
    
    # Verificar namespace con inyección de Istio
    print_info "Verificando inyección de sidecar en namespace 'default'..."
    kubectl label namespace default istio-injection=enabled --overwrite 2>/dev/null || true
    
    # Esperar a que Istio esté listo
    print_info "Esperando a que Istio esté listo..."
    kubectl wait --for=condition=available --timeout=120s deployment/istiod -n istio-system 2>/dev/null || true
    kubectl wait --for=condition=available --timeout=120s deployment/istio-ingressgateway -n istio-system 2>/dev/null || true
    
    # Obtener información de acceso
    MINIKUBE_IP=$(minikube ip -p "$MINIKUBE_PROFILE")
    NODEPORT=$(kubectl get svc istio-ingressgateway -n istio-system -o jsonpath='{.spec.ports[?(@.port==80)].nodePort}' 2>/dev/null || echo "N/A")
    
    # Iniciar dashboards en segundo plano
    print_info "Iniciando dashboards en segundo plano..."
    cd "$ISTIO_DIR" || exit 1

    # Esperar a que los pods estén en estado Running (pueden tardar varios segundos)
    print_info "Esperando a que los pods de observabilidad estén listos..."
    wait_for_pod_running "app.kubernetes.io/name=kiali" istio-system
    wait_for_pod_running "app.kubernetes.io/name=grafana" istio-system
    wait_for_pod_running "app.kubernetes.io/name=jaeger" istio-system

    KIALI_PID=$(start_dashboard_pf kiali 20001 "http://127.0.0.1:20001/kiali")
    JAEGER_PID=$(start_dashboard_pf jaeger 16686 "http://127.0.0.1:16686")
    GRAFANA_PID=$(start_dashboard_pf grafana 3000 "http://127.0.0.1:3000")

    # Los dashboards están listos, abrirlos en una ventana dedicada para poder cerrarla luego
    print_info "Abriendo dashboards en una ventana dedicada con PowerShell (Windows)..."
    BROWSER_PID=$(powershell.exe -Command '$urls = @("http://wsl.localhost:20001/kiali/console","http://wsl.localhost:16686","http://wsl.localhost:3000"); $temp = Join-Path $env:TEMP "microservicios_dashboards"; New-Item -ItemType Directory -Path $temp -ErrorAction SilentlyContinue | Out-Null; $edge = Get-Command msedge -ErrorAction SilentlyContinue; $chrome = Get-Command chrome -ErrorAction SilentlyContinue; $pid = $null; if ($edge) { $args = @("--new-window", "--user-data-dir=$temp\edge", "--profile-directory=Default") + $urls; $p = Start-Process $edge.Source -ArgumentList $args -PassThru -WindowStyle Normal; $pid = $p.Id } elseif ($chrome) { $args = @("--new-window", "--user-data-dir=$temp\chrome", "--profile-directory=Default") + $urls; $p = Start-Process $chrome.Source -ArgumentList $args -PassThru -WindowStyle Normal; $pid = $p.Id } else { foreach ($u in $urls) { Start-Process $u } }; if ($pid) { Write-Output $pid }' | tr -d '
')
    if [ -n "$BROWSER_PID" ]; then
        echo "$BROWSER_PID" > /tmp/microservicios_browser.pid
        print_info "Ventana dedicada de dashboards creada (PID Windows=$BROWSER_PID)"
    else
        print_warning "No se pudo obtener el PID de la ventana del navegador; si queda abierta, ciérrala manualmente"
    fi

    print_success "Sesión iniciada correctamente"
    echo ""
    print_success "Dashboards iniciados (Kiali PID=$KIALI_PID, Jaeger PID=$JAEGER_PID, Grafana PID=$GRAFANA_PID)"
    echo ""
    print_info "Acceso a la API: ${GREEN}http://$MINIKUBE_IP:$NODEPORT${NC}"
    echo ""
    print_info "URLs de dashboards (desde Windows, usa wsl.localhost):"
    echo "  • Kiali:   http://wsl.localhost:20001/kiali/console"
    echo "  • Jaeger:  http://wsl.localhost:16686"
    echo "  • Grafana: http://wsl.localhost:3000"
    echo ""
    print_info "URLs locales (desde WSL/Linux):"
    echo "  • Kiali:   http://127.0.0.1:20001/kiali/console"
    echo "  • Jaeger:  http://127.0.0.1:16686"
    echo "  • Grafana: http://127.0.0.1:3000"
    echo ""
    print_info "Para ver el estado completo:"
    echo "  ./scripts/microservicios status"
}

# STOP: Detener sesión
cmd_stop() {
    print_info "Deteniendo sesión de microservicios..."
    BROWSER_PID=""
    if [ -f /tmp/microservicios_browser.pid ]; then
        BROWSER_PID=$(cat /tmp/microservicios_browser.pid 2>/dev/null || true)
    fi
    
    # Verificar si hay algo corriendo
    if ! is_minikube_running; then
        print_warning "No hay sesión activa de minikube"
        print_info "Usa 'status' para verificar el estado"
        
        # Verificar dashboards huérfanos
        DASH_COUNT=$(count_dashboards)
        if [ "$DASH_COUNT" -gt 0 ]; then
            print_warning "Detectados $DASH_COUNT procesos de dashboard activos"
            print_info "Cerrando dashboards..."
            pkill -f "istioctl dashboard" 2>/dev/null || true
            print_success "Dashboards cerrados"
        fi
    else
        # Limpiar configuraciones de fault injection
        print_info "Limpiando configuraciones de inyección de fallos..."
        kubectl delete -f "$REPO_ROOT/k8s/fault-injection-delay.yaml" --ignore-not-found 2>/dev/null || true
        kubectl delete -f "$REPO_ROOT/k8s/fault-injection-abort.yaml" --ignore-not-found 2>/dev/null || true
        kubectl delete -f "$REPO_ROOT/k8s/fault-injection-combined.yaml" --ignore-not-found 2>/dev/null || true
        kubectl delete -f "$REPO_ROOT/k8s/circuit-breaker.yaml" --ignore-not-found 2>/dev/null || true
        
        # Cerrar dashboards
        DASH_COUNT=$(count_dashboards)
        if [ "$DASH_COUNT" -gt 0 ]; then
            print_info "Cerrando $DASH_COUNT dashboards activos..."
            pkill -f "istioctl dashboard" 2>/dev/null || true
        fi
        
        # Detener minikube
        print_info "Deteniendo minikube..."
        minikube stop -p "$MINIKUBE_PROFILE"
    fi
    
    # Limpiar archivo de PID del navegador si existe
    rm -f /tmp/microservicios_browser.pid 2>/dev/null || true
    
    print_success "Sesión detenida correctamente"
    echo ""
    print_warning "Recuerda cerrar manualmente las ventanas del navegador con los dashboards"
}

# STATUS: Mostrar estado
cmd_status() {
    local DETAIL="${1:-basic}"
    
    echo "════════════════════════════════════════════════════════════"
    echo "  Estado del Entorno de Microservicios"
    echo "════════════════════════════════════════════════════════════"
    echo ""
    
    # Estado de Minikube
    print_info "Minikube:"
    if is_minikube_running; then
        print_success "Estado: Running"
        MINIKUBE_IP=$(minikube ip -p "$MINIKUBE_PROFILE" 2>/dev/null || echo "N/A")
        echo "  IP: $MINIKUBE_IP"
        
        # Obtener información de recursos
        if [ "$DETAIL" = "resources" ] || [ "$DETAIL" = "full" ]; then
            print_info "Recursos de Minikube:"
            minikube ssh -p "$MINIKUBE_PROFILE" "free -h" 2>/dev/null | grep -E "Mem:|Swap:" || true
            echo ""
        fi
    else
        print_error "Estado: Stopped"
        echo ""
        return 0
    fi
    
    # Estado de Kubernetes
    print_info "Kubernetes:"
    KUBE_STATUS=$(kubectl cluster-info 2>&1 | head -n 1)
    if echo "$KUBE_STATUS" | grep -q "running"; then
        print_success "API Server: Running"
    else
        print_error "API Server: No disponible"
    fi
    echo ""
    
    # Pods de Istio
    print_info "Istio (istio-system):"
    ISTIO_PODS=$(kubectl get pods -n istio-system --no-headers 2>/dev/null | wc -l)
    ISTIO_RUNNING=$(kubectl get pods -n istio-system --no-headers 2>/dev/null | grep -c "Running" || echo "0")
    echo "  Pods: $ISTIO_RUNNING/$ISTIO_PODS Running"
    
    if [ "$DETAIL" = "istio" ] || [ "$DETAIL" = "full" ]; then
        kubectl get pods -n istio-system 2>/dev/null | tail -n +2 | awk '{printf "    %-45s %s\n", $1, $3}'
    fi
    echo ""
    
    # Pods de aplicación
    print_info "Microservicios (default):"
    APP_PODS=$(kubectl get pods -n default --no-headers 2>/dev/null | wc -l)
    APP_RUNNING=$(kubectl get pods -n default --no-headers 2>/dev/null | grep -c "Running" || echo "0")
    echo "  Pods: $APP_RUNNING/$APP_PODS Running"
    
    if [ "$DETAIL" = "pods" ] || [ "$DETAIL" = "full" ]; then
        kubectl get pods -n default 2>/dev/null | tail -n +2 | awk '{printf "    %-45s %s\n", $1, $3}'
    fi
    echo ""
    
    # Servicios
    if [ "$DETAIL" = "services" ] || [ "$DETAIL" = "full" ]; then
        print_info "Servicios (default):"
        kubectl get svc -n default 2>/dev/null | tail -n +2 | awk '{printf "    %-30s %-15s %s\n", $1, $3, $5}'
        echo ""
    fi
    
    # Ingress Gateway
    print_info "Istio Ingress Gateway:"
    NODEPORT=$(kubectl get svc istio-ingressgateway -n istio-system -o jsonpath='{.spec.ports[?(@.port==80)].nodePort}' 2>/dev/null || echo "N/A")
    if [ "$NODEPORT" != "N/A" ] && [ -n "$MINIKUBE_IP" ]; then
        echo "  URL: ${GREEN}http://$MINIKUBE_IP:$NODEPORT${NC}"
    else
        print_error "  No disponible"
    fi
    echo ""
    
    # Fault Injection activa
    print_info "Inyección de Fallos:"
    VS_COUNT=$(kubectl get virtualservice -n default --no-headers 2>/dev/null | grep -c "fault" || echo "0")
    DR_COUNT=$(kubectl get destinationrule -n default --no-headers 2>/dev/null | grep -c "circuit-breaker" || echo "0")
    
    if [ "$VS_COUNT" -gt 0 ] || [ "$DR_COUNT" -gt 0 ]; then
        print_warning "Activa ($VS_COUNT VirtualServices, $DR_COUNT DestinationRules)"
        if [ "$DETAIL" = "faults" ] || [ "$DETAIL" = "full" ]; then
            kubectl get virtualservice,destinationrule -n default 2>/dev/null | grep -E "fault|circuit" || true
        fi
    else
        print_success "No hay inyección de fallos activa"
    fi
    echo ""
    
    # Dashboards
    print_info "Dashboards:"
    DASH_COUNT=$(count_dashboards)
    if [ "$DASH_COUNT" -gt 0 ]; then
        print_success "$DASH_COUNT dashboards activos"
        if [ "$DETAIL" = "dashboards" ] || [ "$DETAIL" = "full" ]; then
            ps aux | grep "istioctl dashboard" | grep -v grep | awk '{print "    " $11 " " $12 " (PID: " $2 ")"}'
        fi
        echo "  URLs: http://wsl.localhost:20001/kiali (Kiali)"
        echo "        http://wsl.localhost:16686 (Jaeger)"
        echo "        http://wsl.localhost:3000 (Grafana)"
    else
        echo "  No hay dashboards activos"
        echo "  Usa: ./scripts/microservicios dashboards"
    fi
    echo ""
    
    # Contenedores Docker (si se solicita)
    if [ "$DETAIL" = "containers" ] || [ "$DETAIL" = "full" ]; then
        print_info "Contenedores Docker de Minikube:"
        docker ps --filter "name=minikube" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || echo "  No disponible"
        echo ""
    fi
    
    echo "════════════════════════════════════════════════════════════"
    echo ""
    print_info "Opciones de detalle para 'status':"
    echo "  status resources   - Uso de memoria/CPU"
    echo "  status istio       - Detalle de pods de Istio"
    echo "  status pods        - Detalle de pods de aplicación"
    echo "  status services    - Lista de servicios"
    echo "  status faults      - Configuraciones de fault injection"
    echo "  status dashboards  - Procesos de dashboard activos"
    echo "  status containers  - Contenedores Docker"
    echo "  status full        - Toda la información"
}

# DASHBOARDS: Abrir dashboards en segundo plano
cmd_dashboards() {
    local DASHBOARD="${1:-all}"
    
    if ! is_minikube_running; then
        print_error "Minikube no está corriendo"
        print_info "Usa './scripts/microservicios start' primero"
        return 1
    fi
    
    cd "$ISTIO_DIR" || exit 1
    
    # Función auxiliar para abrir navegador desde PowerShell
    open_browser() {
        local URL=$1
        powershell.exe -Command "Start-Process '$URL'" 2>/dev/null || true
    }
    
    case "$DASHBOARD" in
        kiali|k)
            print_info "Abriendo Kiali en segundo plano..."
            wait_for_deploy_available kiali
            KIALI_PID=$(start_dashboard_pf kiali 20001 "http://127.0.0.1:20001/kiali")
            print_success "Kiali iniciado (PID: $KIALI_PID)"
            print_info "Accede desde Windows en: http://wsl.localhost:20001/kiali/console"
            open_browser "http://wsl.localhost:20001/kiali/console"
            ;;
        jaeger|j)
            print_info "Abriendo Jaeger en segundo plano..."
            wait_for_deploy_available jaeger
            JAEGER_PID=$(start_dashboard_pf jaeger 16686 "http://127.0.0.1:16686")
            print_success "Jaeger iniciado (PID: $JAEGER_PID)"
            print_info "Accede desde Windows en: http://wsl.localhost:16686"
            open_browser "http://wsl.localhost:16686"
            ;;
        grafana|g)
            print_info "Abriendo Grafana en segundo plano..."
            wait_for_deploy_available grafana
            GRAFANA_PID=$(start_dashboard_pf grafana 3000 "http://127.0.0.1:3000")
            print_success "Grafana iniciado (PID: $GRAFANA_PID)"
            print_info "Accede desde Windows en: http://wsl.localhost:3000"
            open_browser "http://wsl.localhost:3000"
            ;;
        all|*)
            print_info "Abriendo todos los dashboards en segundo plano..."
            wait_for_deploy_available kiali
            wait_for_deploy_available jaeger
            wait_for_deploy_available grafana

            KIALI_PID=$(start_dashboard_pf kiali 20001 "http://127.0.0.1:20001/kiali")
            JAEGER_PID=$(start_dashboard_pf jaeger 16686 "http://127.0.0.1:16686")
            GRAFANA_PID=$(start_dashboard_pf grafana 3000 "http://127.0.0.1:3000")
            
            print_success "Dashboards iniciados (puertos fijos):"
            echo "  • Kiali:   http://wsl.localhost:20001/kiali/console (PID: $KIALI_PID)"
            echo "  • Jaeger:  http://wsl.localhost:16686 (PID: $JAEGER_PID)"
            echo "  • Grafana: http://wsl.localhost:3000 (PID: $GRAFANA_PID)"
            
            open_browser "http://wsl.localhost:20001/kiali/console"
            open_browser "http://wsl.localhost:16686"
            open_browser "http://wsl.localhost:3000"
            ;;
    esac
    
    echo ""
    print_info "Los dashboards seguirán corriendo en segundo plano"
    print_info "Usa 'status dashboards' para ver procesos activos"
}

# LOGS: Ver logs de un servicio
cmd_logs() {
    local SERVICE="${1:-usuarios}"
    local LINES="${2:-50}"
    
    if ! is_minikube_running; then
        print_error "Minikube no está corriendo"
        return 1
    fi
    
    print_info "Logs de microservicio-$SERVICE (últimas $LINES líneas):"
    kubectl logs -l app=microservicio-"$SERVICE" -n default --tail="$LINES" --prefix 2>/dev/null || \
        print_error "No se encontró el servicio 'microservicio-$SERVICE'"
}

# TEST: Probar la API
cmd_test() {
    if ! is_minikube_running; then
        print_error "Minikube no está corriendo"
        return 1
    fi
    
    MINIKUBE_IP=$(minikube ip -p "$MINIKUBE_PROFILE")
    NODEPORT=$(kubectl get svc istio-ingressgateway -n istio-system -o jsonpath='{.spec.ports[?(@.port==80)].nodePort}')
    
    print_info "Probando API en http://$MINIKUBE_IP:$NODEPORT/usuarios"
    echo ""
    
    # GET usuarios
    print_info "GET /usuarios:"
    curl -s "http://$MINIKUBE_IP:$NODEPORT/usuarios" | jq . 2>/dev/null || curl -s "http://$MINIKUBE_IP:$NODEPORT/usuarios"
    echo ""
    echo ""
    
    # POST usuario
    print_info "POST /usuarios (creando usuario 'TestUser'):"
    curl -s -X POST "http://$MINIKUBE_IP:$NODEPORT/usuarios" \
        -H "Content-Type: application/json" \
        -d '{"nombre":"TestUser"}' | jq . 2>/dev/null || \
        curl -s -X POST "http://$MINIKUBE_IP:$NODEPORT/usuarios" \
        -H "Content-Type: application/json" \
        -d '{"nombre":"TestUser"}'
    echo ""
}

# HELP: Mostrar ayuda
cmd_help() {
    cat << EOF
Uso: ./scripts/microservicios <comando> [opciones]

Comandos principales:
  start                  Iniciar sesión (minikube + verificaciones)
  stop                   Detener sesión (limpia fault injection + minikube)
  status [detalle]       Mostrar estado de la sesión
  
Comandos auxiliares:
  dashboards [tipo]      Abrir dashboards en segundo plano
                         Tipos: all (default), kiali, jaeger, grafana
  logs [servicio] [n]    Ver logs de un servicio (default: usuarios, 50 líneas)
  test                   Probar la API (GET/POST /usuarios)
  help                   Mostrar esta ayuda

Opciones de 'status':
  status                 Estado básico (default)
  status resources       Uso de memoria/CPU del cluster
  status istio           Detalle de pods de Istio
  status pods            Detalle de pods de aplicación
  status services        Lista de servicios
  status faults          Configuraciones activas de fault injection
  status dashboards      Procesos de dashboard activos
  status containers      Contenedores Docker de minikube
  status full            Toda la información

Ejemplos:
  ./scripts/microservicios start
  ./scripts/microservicios dashboards kiali
  ./scripts/microservicios status full
  ./scripts/microservicios logs notificaciones 100
  ./scripts/microservicios test
  ./scripts/microservicios stop

EOF
}

# Main
COMMAND="${1:-help}"

case "$COMMAND" in
    start)
        cmd_start
        ;;
    stop)
        cmd_stop
        ;;
    status)
        cmd_status "${2:-basic}"
        ;;
    dashboards|dash)
        cmd_dashboards "${2:-all}"
        ;;
    logs)
        cmd_logs "${2:-usuarios}" "${3:-50}"
        ;;
    test)
        cmd_test
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        print_error "Comando desconocido: $COMMAND"
        echo ""
        cmd_help
        exit 1
        ;;
esac
