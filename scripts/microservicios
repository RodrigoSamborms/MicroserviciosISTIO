#!/usr/bin/env bash
set -euo pipefail

# Configuración
REPO_ROOT="/mnt/c/Users/sambo/Documents/Programacion/GitHub/MicroserviciosISTIO"
ISTIO_DIR="$REPO_ROOT/istio-1.28.0"
MINIKUBE_PROFILE="minikube"
MEMORY="2048"
CPUS="2"

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Funciones auxiliares
print_info() { echo -e "${BLUE}ℹ${NC} $1"; }
print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }
print_error() { echo -e "${RED}✗${NC} $1"; }

# Verificar si minikube está corriendo
is_minikube_running() {
    minikube status -p "$MINIKUBE_PROFILE" 2>/dev/null | grep -q "host: Running" && return 0 || return 1
}

# Verificar si hay dashboards corriendo
get_dashboard_pids() {
    pgrep -f "istioctl dashboard" 2>/dev/null || true
}

count_dashboards() {
    get_dashboard_pids | wc -l
}

# START: Iniciar sesión
cmd_start() {
    print_info "Iniciando sesión de microservicios..."
    
    # Verificar si ya está corriendo
    if is_minikube_running; then
        print_warning "Minikube ya está en ejecución"
        print_info "Usa 'status' para ver detalles o 'stop' para detener"
        return 0
    fi
    
    # Iniciar minikube
    print_info "Iniciando minikube (memoria=${MEMORY}MB, cpus=${CPUS})..."
    minikube start --driver=docker --memory="$MEMORY" --cpus="$CPUS" -p "$MINIKUBE_PROFILE"
    
    # Verificar namespace con inyección de Istio
    print_info "Verificando inyección de sidecar en namespace 'default'..."
    kubectl label namespace default istio-injection=enabled --overwrite 2>/dev/null || true
    
    # Esperar a que Istio esté listo
    print_info "Esperando a que Istio esté listo..."
    kubectl wait --for=condition=available --timeout=120s deployment/istiod -n istio-system 2>/dev/null || true
    kubectl wait --for=condition=available --timeout=120s deployment/istio-ingressgateway -n istio-system 2>/dev/null || true
    
    # Obtener información de acceso
    MINIKUBE_IP=$(minikube ip -p "$MINIKUBE_PROFILE")
    NODEPORT=$(kubectl get svc istio-ingressgateway -n istio-system -o jsonpath='{.spec.ports[?(@.port==80)].nodePort}' 2>/dev/null || echo "N/A")
    
    # Iniciar dashboards en segundo plano con puertos fijos y bind 0.0.0.0
    print_info "Iniciando dashboards en segundo plano..."
    cd "$ISTIO_DIR" || exit 1

    start_dash() {
        local NAME=$1
        local PORT=$2
        local URL=$3
        local LOGFILE="/tmp/microservicios_${NAME}.log"
        nohup ./bin/istioctl dashboard --port "$PORT" --address 0.0.0.0 --browser=false "$NAME" > "$LOGFILE" 2>&1 &
        echo $!
    }

    KIALI_PID=$(start_dash kiali 20001 "http://localhost:20001/kiali/console")
    sleep 2
    JAEGER_PID=$(start_dash jaeger 16686 "http://localhost:16686")
    sleep 2
    GRAFANA_PID=$(start_dash grafana 3000 "http://localhost:3000")
    sleep 2

    # Abrir navegadores
    print_info "Abriendo dashboards en el navegador..."
    if command -v wslview &> /dev/null; then
        wslview "http://localhost:20001/kiali/console" &
        wslview "http://localhost:16686" &
        wslview "http://localhost:3000" &
    elif command -v explorer.exe &> /dev/null; then
        explorer.exe "http://localhost:20001/kiali/console" &
        explorer.exe "http://localhost:16686" &
        explorer.exe "http://localhost:3000" &
    else
        print_warning "No se pudo detectar navegador. Abre manualmente:"
        echo "  • Kiali:   http://localhost:20001/kiali/console"
        echo "  • Jaeger:  http://localhost:16686"
        echo "  • Grafana: http://localhost:3000"
    fi

    print_success "Sesión iniciada correctamente"
    echo ""
    print_success "Dashboards iniciados (PIDs: Kiali=$KIALI_PID, Jaeger=$JAEGER_PID, Grafana=$GRAFANA_PID)"
    echo ""
    print_info "Acceso a la API: ${GREEN}http://$MINIKUBE_IP:$NODEPORT${NC}"
    echo ""
    print_info "URLs de dashboards:"
    echo "  • Kiali:   http://localhost:20001/kiali/console"
    echo "  • Jaeger:  http://localhost:16686"
    echo "  • Grafana: http://localhost:3000"
    echo ""
    print_info "Para ver el estado completo:"
    echo "  ./scripts/microservicios status"
}

# STOP: Detener sesión
cmd_stop() {
    print_info "Deteniendo sesión de microservicios..."
    
    # Verificar si hay algo corriendo
    if ! is_minikube_running; then
        print_warning "No hay sesión activa de minikube"
        print_info "Usa 'status' para verificar el estado"
        
        # Verificar dashboards huérfanos
        DASH_COUNT=$(count_dashboards)
        if [ "$DASH_COUNT" -gt 0 ]; then
            print_warning "Detectados $DASH_COUNT procesos de dashboard activos"
            print_info "Cerrando dashboards..."
            pkill -f "istioctl dashboard" 2>/dev/null || true
            print_success "Dashboards cerrados"
        fi
        return 0
    fi
    
    # Limpiar configuraciones de fault injection
    print_info "Limpiando configuraciones de inyección de fallos..."
    kubectl delete -f "$REPO_ROOT/k8s/fault-injection-delay.yaml" --ignore-not-found 2>/dev/null || true
    kubectl delete -f "$REPO_ROOT/k8s/fault-injection-abort.yaml" --ignore-not-found 2>/dev/null || true
    kubectl delete -f "$REPO_ROOT/k8s/fault-injection-combined.yaml" --ignore-not-found 2>/dev/null || true
    kubectl delete -f "$REPO_ROOT/k8s/circuit-breaker.yaml" --ignore-not-found 2>/dev/null || true
    
    # Cerrar dashboards
    DASH_COUNT=$(count_dashboards)
    if [ "$DASH_COUNT" -gt 0 ]; then
        print_info "Cerrando $DASH_COUNT dashboards activos..."
        pkill -f "istioctl dashboard" 2>/dev/null || true
    fi
    
    # Detener minikube
    print_info "Deteniendo minikube..."
    minikube stop -p "$MINIKUBE_PROFILE"
    
    print_success "Sesión detenida correctamente"
}

# STATUS: Mostrar estado
cmd_status() {
    local DETAIL="${1:-basic}"
    
    echo "════════════════════════════════════════════════════════════"
    echo "  Estado del Entorno de Microservicios"
    echo "════════════════════════════════════════════════════════════"
    echo ""
    
    # Estado de Minikube
    print_info "Minikube:"
    if is_minikube_running; then
        print_success "Estado: Running"
        MINIKUBE_IP=$(minikube ip -p "$MINIKUBE_PROFILE" 2>/dev/null || echo "N/A")
        echo "  IP: $MINIKUBE_IP"
        
        # Obtener información de recursos
        if [ "$DETAIL" = "resources" ] || [ "$DETAIL" = "full" ]; then
            print_info "Recursos de Minikube:"
            minikube ssh -p "$MINIKUBE_PROFILE" "free -h" 2>/dev/null | grep -E "Mem:|Swap:" || true
            echo ""
        fi
    else
        print_error "Estado: Stopped"
        echo ""
        return 0
    fi
    
    # Estado de Kubernetes
    print_info "Kubernetes:"
    KUBE_STATUS=$(kubectl cluster-info 2>&1 | head -n 1)
    if echo "$KUBE_STATUS" | grep -q "running"; then
        print_success "API Server: Running"
    else
        print_error "API Server: No disponible"
    fi
    echo ""
    
    # Pods de Istio
    print_info "Istio (istio-system):"
    ISTIO_PODS=$(kubectl get pods -n istio-system --no-headers 2>/dev/null | wc -l)
    ISTIO_RUNNING=$(kubectl get pods -n istio-system --no-headers 2>/dev/null | grep -c "Running" || echo "0")
    echo "  Pods: $ISTIO_RUNNING/$ISTIO_PODS Running"
    
    if [ "$DETAIL" = "istio" ] || [ "$DETAIL" = "full" ]; then
        kubectl get pods -n istio-system 2>/dev/null | tail -n +2 | awk '{printf "    %-45s %s\n", $1, $3}'
    fi
    echo ""
    
    # Pods de aplicación
    print_info "Microservicios (default):"
    APP_PODS=$(kubectl get pods -n default --no-headers 2>/dev/null | wc -l)
    APP_RUNNING=$(kubectl get pods -n default --no-headers 2>/dev/null | grep -c "Running" || echo "0")
    echo "  Pods: $APP_RUNNING/$APP_PODS Running"
    
    if [ "$DETAIL" = "pods" ] || [ "$DETAIL" = "full" ]; then
        kubectl get pods -n default 2>/dev/null | tail -n +2 | awk '{printf "    %-45s %s\n", $1, $3}'
    fi
    echo ""
    
    # Servicios
    if [ "$DETAIL" = "services" ] || [ "$DETAIL" = "full" ]; then
        print_info "Servicios (default):"
        kubectl get svc -n default 2>/dev/null | tail -n +2 | awk '{printf "    %-30s %-15s %s\n", $1, $3, $5}'
        echo ""
    fi
    
    # Ingress Gateway
    print_info "Istio Ingress Gateway:"
    NODEPORT=$(kubectl get svc istio-ingressgateway -n istio-system -o jsonpath='{.spec.ports[?(@.port==80)].nodePort}' 2>/dev/null || echo "N/A")
    if [ "$NODEPORT" != "N/A" ] && [ -n "$MINIKUBE_IP" ]; then
        echo "  URL: ${GREEN}http://$MINIKUBE_IP:$NODEPORT${NC}"
    else
        print_error "  No disponible"
    fi
    echo ""
    
    # Fault Injection activa
    print_info "Inyección de Fallos:"
    VS_COUNT=$(kubectl get virtualservice -n default --no-headers 2>/dev/null | grep -c "fault" || echo "0")
    DR_COUNT=$(kubectl get destinationrule -n default --no-headers 2>/dev/null | grep -c "circuit-breaker" || echo "0")
    
    if [ "$VS_COUNT" -gt 0 ] || [ "$DR_COUNT" -gt 0 ]; then
        print_warning "Activa ($VS_COUNT VirtualServices, $DR_COUNT DestinationRules)"
        if [ "$DETAIL" = "faults" ] || [ "$DETAIL" = "full" ]; then
            kubectl get virtualservice,destinationrule -n default 2>/dev/null | grep -E "fault|circuit" || true
        fi
    else
        print_success "No hay inyección de fallos activa"
    fi
    echo ""
    
    # Dashboards
    print_info "Dashboards:"
    DASH_COUNT=$(count_dashboards)
    if [ "$DASH_COUNT" -gt 0 ]; then
        print_success "$DASH_COUNT dashboards activos"
        if [ "$DETAIL" = "dashboards" ] || [ "$DETAIL" = "full" ]; then
            ps aux | grep "istioctl dashboard" | grep -v grep | awk '{print "    " $11 " " $12 " (PID: " $2 ")"}'
        fi
    else
        echo "  No hay dashboards activos"
        echo "  Usa: ./scripts/microservicios dashboards"
    fi
    echo ""
    
    # Contenedores Docker (si se solicita)
    if [ "$DETAIL" = "containers" ] || [ "$DETAIL" = "full" ]; then
        print_info "Contenedores Docker de Minikube:"
        docker ps --filter "name=minikube" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || echo "  No disponible"
        echo ""
    fi
    
    echo "════════════════════════════════════════════════════════════"
    echo ""
    print_info "Opciones de detalle para 'status':"
    echo "  status resources   - Uso de memoria/CPU"
    echo "  status istio       - Detalle de pods de Istio"
    echo "  status pods        - Detalle de pods de aplicación"
    echo "  status services    - Lista de servicios"
    echo "  status faults      - Configuraciones de fault injection"
    echo "  status dashboards  - Procesos de dashboard activos"
    echo "  status containers  - Contenedores Docker"
    echo "  status full        - Toda la información"
}

# DASHBOARDS: Abrir dashboards en segundo plano
cmd_dashboards() {
    local DASHBOARD="${1:-all}"
    
    if ! is_minikube_running; then
        print_error "Minikube no está corriendo"
        print_info "Usa './scripts/microservicios start' primero"
        return 1
    fi
    
    cd "$ISTIO_DIR" || exit 1
    
    # Función auxiliar para abrir navegador
    open_browser() {
        local URL=$1
        if command -v wslview &> /dev/null; then
            wslview "$URL" &
        elif command -v explorer.exe &> /dev/null; then
            explorer.exe "$URL" &
        fi
    }
    
    case "$DASHBOARD" in
        kiali|k)
            print_info "Abriendo Kiali en segundo plano..."
            nohup ./bin/istioctl dashboard --port 20001 --address 0.0.0.0 --browser=false kiali > /tmp/microservicios_kiali.log 2>&1 &
            KIALI_PID=$!
            sleep 2
            print_success "Kiali iniciado (PID: $KIALI_PID)"
            print_info "Accede en: http://localhost:20001/kiali/console"
            open_browser "http://localhost:20001/kiali/console"
            ;;
        jaeger|j)
            print_info "Abriendo Jaeger en segundo plano..."
            nohup ./bin/istioctl dashboard --port 16686 --address 0.0.0.0 --browser=false jaeger > /tmp/microservicios_jaeger.log 2>&1 &
            JAEGER_PID=$!
            sleep 2
            print_success "Jaeger iniciado (PID: $JAEGER_PID)"
            print_info "Accede en: http://localhost:16686"
            open_browser "http://localhost:16686"
            ;;
        grafana|g)
            print_info "Abriendo Grafana en segundo plano..."
            nohup ./bin/istioctl dashboard --port 3000 --address 0.0.0.0 --browser=false grafana > /tmp/microservicios_grafana.log 2>&1 &
            GRAFANA_PID=$!
            sleep 2
            print_success "Grafana iniciado (PID: $GRAFANA_PID)"
            print_info "Accede en: http://localhost:3000"
            open_browser "http://localhost:3000"
            ;;
        all|*)
            print_info "Abriendo todos los dashboards en segundo plano..."
            nohup ./bin/istioctl dashboard --port 20001 --address 0.0.0.0 --browser=false kiali > /tmp/microservicios_kiali.log 2>&1 &
            KIALI_PID=$!
            sleep 2
            nohup ./bin/istioctl dashboard --port 16686 --address 0.0.0.0 --browser=false jaeger > /tmp/microservicios_jaeger.log 2>&1 &
            JAEGER_PID=$!
            sleep 2
            nohup ./bin/istioctl dashboard --port 3000 --address 0.0.0.0 --browser=false grafana > /tmp/microservicios_grafana.log 2>&1 &
            GRAFANA_PID=$!
            sleep 2
            
            print_success "Dashboards iniciados:"
            echo "  • Kiali:   http://localhost:20001/kiali/console (PID: $KIALI_PID)"
            echo "  • Jaeger:  http://localhost:16686 (PID: $JAEGER_PID)"
            echo "  • Grafana: http://localhost:3000 (PID: $GRAFANA_PID)"
            
            print_info "Abriendo navegadores..."
            open_browser "http://localhost:20001/kiali/console"
            open_browser "http://localhost:16686"
            open_browser "http://localhost:3000"
            ;;
    esac
    
    echo ""
    print_info "Los dashboards seguirán corriendo en segundo plano"
    print_info "Usa 'status dashboards' para ver procesos activos"
}

# LOGS: Ver logs de un servicio
cmd_logs() {
    local SERVICE="${1:-usuarios}"
    local LINES="${2:-50}"
    
    if ! is_minikube_running; then
        print_error "Minikube no está corriendo"
        return 1
    fi
    
    print_info "Logs de microservicio-$SERVICE (últimas $LINES líneas):"
    kubectl logs -l app=microservicio-"$SERVICE" -n default --tail="$LINES" --prefix 2>/dev/null || \
        print_error "No se encontró el servicio 'microservicio-$SERVICE'"
}

# TEST: Probar la API
cmd_test() {
    if ! is_minikube_running; then
        print_error "Minikube no está corriendo"
        return 1
    fi
    
    MINIKUBE_IP=$(minikube ip -p "$MINIKUBE_PROFILE")
    NODEPORT=$(kubectl get svc istio-ingressgateway -n istio-system -o jsonpath='{.spec.ports[?(@.port==80)].nodePort}')
    
    print_info "Probando API en http://$MINIKUBE_IP:$NODEPORT/usuarios"
    echo ""
    
    # GET usuarios
    print_info "GET /usuarios:"
    curl -s "http://$MINIKUBE_IP:$NODEPORT/usuarios" | jq . 2>/dev/null || curl -s "http://$MINIKUBE_IP:$NODEPORT/usuarios"
    echo ""
    echo ""
    
    # POST usuario
    print_info "POST /usuarios (creando usuario 'TestUser'):"
    curl -s -X POST "http://$MINIKUBE_IP:$NODEPORT/usuarios" \
        -H "Content-Type: application/json" \
        -d '{"nombre":"TestUser"}' | jq . 2>/dev/null || \
        curl -s -X POST "http://$MINIKUBE_IP:$NODEPORT/usuarios" \
        -H "Content-Type: application/json" \
        -d '{"nombre":"TestUser"}'
    echo ""
}

# HELP: Mostrar ayuda
cmd_help() {
    cat << EOF
Uso: ./scripts/microservicios <comando> [opciones]

Comandos principales:
  start                  Iniciar sesión (minikube + verificaciones)
  stop                   Detener sesión (limpia fault injection + minikube)
  status [detalle]       Mostrar estado de la sesión
  
Comandos auxiliares:
  dashboards [tipo]      Abrir dashboards en segundo plano
                         Tipos: all (default), kiali, jaeger, grafana
  logs [servicio] [n]    Ver logs de un servicio (default: usuarios, 50 líneas)
  test                   Probar la API (GET/POST /usuarios)
  help                   Mostrar esta ayuda

Opciones de 'status':
  status                 Estado básico (default)
  status resources       Uso de memoria/CPU del cluster
  status istio           Detalle de pods de Istio
  status pods            Detalle de pods de aplicación
  status services        Lista de servicios
  status faults          Configuraciones activas de fault injection
  status dashboards      Procesos de dashboard activos
  status containers      Contenedores Docker de minikube
  status full            Toda la información

Ejemplos:
  ./scripts/microservicios start
  ./scripts/microservicios dashboards kiali
  ./scripts/microservicios status full
  ./scripts/microservicios logs notificaciones 100
  ./scripts/microservicios test
  ./scripts/microservicios stop

EOF
}

# Main
COMMAND="${1:-help}"

case "$COMMAND" in
    start)
        cmd_start
        ;;
    stop)
        cmd_stop
        ;;
    status)
        cmd_status "${2:-basic}"
        ;;
    dashboards|dash)
        cmd_dashboards "${2:-all}"
        ;;
    logs)
        cmd_logs "${2:-usuarios}" "${3:-50}"
        ;;
    test)
        cmd_test
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        print_error "Comando desconocido: $COMMAND"
        echo ""
        cmd_help
        exit 1
        ;;
esac
